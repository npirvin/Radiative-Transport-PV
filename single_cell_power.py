""" Created on Thu Jun 21 14:31:46 2018
Author: Nicholas Irvin 

This module determines the output power of a cell.
If using the diffusion model, then spectral.py calculates the total current,
   and this module calcualtes the power.
If not using the diffusion model, then spectral.py calculates photogeneration current 
   and recombinaiton.py calculates recombinaiton current, and the difference is found here.
Finally the function max-power-pt here maximizes the power. """

# Import libraries
import numpy as np
from scipy.optimize import  minimize_scalar, brentq
import matplotlib.pyplot as plt  # useful for plotting IV curves
import spectral, recombination, sunlight



# Set constants
c = 2.99792458e8               
# m/s  The speed of light
h = 6.6260755e-34              
# J*s  Planck's constant
k = 1.38064852e-23               
# J/K  Boltzmann's constant
q = 1.60217653e-19       
# C    The charge of an electron
g = 2*np.pi/(c**2)/(h**3)      
# s^5/(kg^3*m^8)  The coefficient for particle flux
f = 1/46248.5                    
# (sr) Sunlight dilution factor, which is surface area of the Sun divided by
# surface area of sphere with radius equal to Sun's distance from Earth


def find_Jgen(E1, E2, volt, photocollection, stack):
    """ Purpose: Calculate short-circuit current Jsc (A m^-2) given energy bounds for radiation.
    Concentration is the sunlight concentration in units of suns.
    Used by find_current, find_voltage, and max_power_pt. """

    # Current generated by incident sunlight/laser_light.
    J_Sun =   spectral.Photocollection(E1, stack).J
    if stack.spectrum == 'Blackbody':
        J_Sun = f*J_Sun     
    return(J_Sun)
    



def find_current(volt, E1, E2, photocollection, stack, Jsc=0, extra_plots='No'):
    """ Purpose: Find net current density (A m^-2). 
    
    Used by max_power_pt. """ 

    stack.extra_plots = 'Yes' if extra_plots == 'Yes' else 'No'  # Turned on to tell inner functions to only make an plot. Useful to only plot at a certain voltage.
    
    photocollection = spectral.Photocollection(E1, stack, volt=volt)  # need to redo optical calculation before finding recombination
    rec = recombination.Recombination(volt, E1, E2, photocollection, stack)
    if Jsc == 0 and stack.diffusion_limited == 'No':             
        Jgen = find_Jgen(E1, E2, volt, photocollection, stack)
    else: 
        Jgen = Jsc
    if stack.diffusion_limited == 'No':
        J = Jgen - abs(rec.J_recombination)
    if stack.diffusion_limited == 'Yes':
        J = spectral.Photocollection(E1, stack, volt=volt, tau=rec.bulk_lifetime, diffusion_length=rec.diffusion_length, diffusivity=rec.diffusivity, absorptance=photocollection.absorptance, rear_emittance=photocollection.rear_emittance, rec=rec).J
    return J



# for special multijunction connections (aks structures). Needs reverification.
def find_voltage(J, E1, E2, photocollection, stack, Jsc=0):     # Redo
    """ Purpose: Calculate voltage as a function of current.
    This function can be used for graphing the I-V curve. 
    Used by max_power_pt. """
    
    if Jsc == 0:
        Jsc = find_Jgen(E1, E2, 0.01, photocollection, stack)


    def current_minus_current(volt):        
        photocollection = spectral.Photocollection(E1, stack, volt=volt) 
        rec = recombination.Recombination(volt, E1, E2, photocollection, stack)
        stack.recombination_data = rec
        J_recombination = rec.J_recombination
        if Jsc == 0 or stack.voltage_dependent_Jgen == 'On':
            Jgen = find_Jgen(E1, E2, volt, photocollection, stack)  # Jsc
        else: 
            Jgen = Jsc
        if stack.diffusion_limited == 'Yes':
            return(abs(Jgen - J)) 
        else:
            return(abs(Jgen - abs(J_recombination) - J))  
            # Finding a zero of 'Jsc - J_rec - J' finds the voltage that 
            # satisfies the definition 'J = Jsc - J_dark'.
    VocCarnot = sunlight.Incident_Light(stack.spectrum, stack, extra=1, Eg=E1).VocCarnot  # Maximum possible Voc
    volt = minimize_scalar(current_minus_current, bounds=[0, VocCarnot], method='Bounded').x
    
    return(volt)   # returns cell voltage without resistive loss
    



class IV_Data:
    """ Get IV data and display IV curve.
    Used by max_power_pt.py. Outputs Jsc, Voc, FF"""
    def __init__(self, Vmp, power, E1, E2, photocollection, stack, Jsc):
        if stack.number_of_bandgaps == 1:
            def current(volt):   
                return find_current(volt, E1, E2, photocollection, stack, Jsc)
            
            # Voc, FF.  Jsc was calcualted in max_power_pt 
            print('Jsc = ', round(Jsc/10,4), ' mA/cm^2')  # This is the Jsc without series resistance)
            VocCarnot = sunlight.Incident_Light(stack.spectrum, stack, extra=1).VocCarnot
            if stack.find_Voc == 'No':
                Voc = 0
                FF = 0
            else:
                try:
                    Voc = brentq(current, 0, VocCarnot, rtol=1e-4)  # some advanced-concept features like selective reflectors can make Voc above the bandgap
                except:
                    try:
                        Voc = brentq(current, 0, E1, rtol=1e-4)
                    except:
                        Voc = 0
                FF = 100*power/(Voc*Jsc)
                print('Voc = ', round(Voc,4), 'V.')
                print('FF = ', round(FF,5), '%.\n')

            self.Jsc = Jsc # A/m^2    
            self.Voc = Voc # V
            self.FF = FF # %
            self.Vmp = Vmp # V
            self.Jmp = stack.Jmp # A/m^2
            
            # Radiative info
            flux_S = find_Jgen(E1, E2, 0, photocollection, stack)/q
            flux_B = spectral.Flux(0, 10, stack.T_cell, 0.00000001, photocollection, stack, note='Calculating Jo').front_flux
            self.Vdb = k*stack.T_cell/q*np.log(flux_S/flux_B)
            self.Jph_mp = find_current(Vmp, E1, E2, photocollection, stack) + stack.rec.J_recombination # A/m^2

            # Extra saved data at the test point
            V_test = stack.V_test        
            if V_test == 'Vmp':
                V_test = Vmp
            if V_test == 'Voc':
                V_test = Voc
            stack.V_test = V_test  
            self.Jph_test = find_current(V_test, E1, E2, photocollection, stack) + stack.rec.J_recombination # A/m^2
            rec = stack.rec   # should be at V_test
            self.rec = rec
            if stack.composition != []:
                PR = rec.P_PR
            else:
                PR = 0
            self.PR = PR

            # special use - to compare Jrad_abs and Jrad_EQE models for Jrad paper:            
            abs_flux = spectral.Flux( E1, E2, stack.T_cell, V_test, photocollection, stack, model='absorptance')
            self.J_rad_abs = q*abs_flux.flux  # A/m^2
            
            
            # # Plot IV curve? then uncomment this block
            # if not plt.fignum_exists(5):  # Already made a plot
            #     Vmax = Voc
            #     number_points =61
            #     V_list = [i*Vmax/(number_points) for i in np.linspace(1,number_points)]
            #     # number_points =100001
            #     # V_list = [i*Vmax/(number_points-1) for i in np.linspace(99900,number_points)]
            #     I_list = np.array([])
            #     V_r_list = []
            #     for volt in V_list:
            #         I = find_current(volt, E1, E2, photocollection, stack, Jsc)/stack.concentration
            #         I_list = np.append(I_list, I)
            #         Rseries = stack.R_series  # (ohms*m^2)
            #         volt = volt - stack.V_drop
            #         V_r = volt - I*Rseries   # doesn't work well if R is large, like 1 ohm*m^2, then the V_r data gets stretched 
            #         # V_r = stack.V_right
            #         V_r = max(V_r, 0)
            #         V_r_list += [V_r]  # Voltage drop due to Rseries
            #     plt.rc('font', family='sans-serif')
            #     fig, ax = plt.subplots()
            #     plt.xlim(0, min(1.1*Voc,1.05*stack.bandgap))
            #     plt.ylim(-.001, 1.1*Jsc/10)
            #     ax.minorticks_on()
            #     ax.set_xlabel('Volt (V)')
            #     ax.set_ylabel('Current (mA/cm$^2$)')
            #     ax.plot(V_r_list, I_list/10) #/10 for mA.cm^2               
            # find_current(stack.V_test, E1, E2, photocollection, stack, Jsc, extra_plots='Yes')


        else:
            self.Jsc = 0
            self.Voc = 0
            self.FF = 0
            self.Jmp = 0
            self.Vmp = 0
            self.J_Auger = 0
            self.PR = 0
            self.Vdb = 0
            self.J_rad_front = 0         
            self.J_rad_back = 0 
            self.Jph = 0
            self.ERE = 0

            


        
        
        

def max_power_pt(E1, E2, stack):
    """ Purpose: Calculate maximum power (W m^-2) for a cell between voltages E1 
    and E2.
    Output: voltage at maximum power, maximum power
    Used by independent_cell_power in the stack module. """												

    stack.set_bandgap(E1)
    photocollection = spectral.Photocollection(E1, stack, volt=0.01)
    Jsc = find_current(.01, E1, E2, photocollection, stack)
         
    R_series = 0 # can add external series resistance in here  (in ohms*cm^2)
    R_series = R_series*1e-4 # convert to ohms*m^2
    stack.R_series = R_series

    
    ## prepare to optimize power
    def power_fun(volt): 
        current = find_current(volt, E1, E2, photocollection, stack, Jsc)
        if stack.nonradiative_recombination_modeling == 'Yes':
            volt_r = volt - stack.V_drop # Voltage drop due to internal Rseries
            volt_r = volt_r - current*R_series # Voltage drop due to external Rseries
            volt_r = max(volt_r, 0)
            stack.Vmp = volt_r
            stack.Jmp = current   
        else:
            volt_r = volt
            
        return -volt_r*current

    VocCarnot = sunlight.Incident_Light(stack.spectrum, stack, extra=1).VocCarnot  # Maximum possible Voc
    bound = max(VocCarnot, E1)
    res = minimize_scalar(power_fun, bounds=[0, bound], method='Bounded')  # do we just need 4 figures of precision?  , options={'xatol': 1e-5}
    power = -res.fun
    IV_data = IV_Data(stack.Vmp, power, E1, E2, photocollection, stack, Jsc)
    return power, IV_data
